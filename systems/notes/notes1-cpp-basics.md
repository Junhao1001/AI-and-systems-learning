# C++ basics

## 1. basics

- C++是种编译型语言：要运行一个程序，其源文本需要通过编译器处理， 生成一些目标文件，再经链接器组合后给出一个可执行文件

![image-20251217163025598](./images/notes1-cpp-basics/image-20251217163025598.png)

- 每个 C++ 程序必须有且只有一个名为`main()`的全局函数，作为所有程序的起点

- `std` 是 **C++ Standard Library（标准库）的命名空间**

  - 凡是 C++ 标准库中定义的内容，几乎都放在 `std` 里面，例如：

  ```cpp
  std::cout      // 标准输出流
  std::cin       // 标准输入流
  std::cerr      // 标准错误输出流
  std::string    // 字符串类
  std::vector    // 动态数组
  ```

- **函数**：

  - 函数可以作为类的成员。 对于*成员函数（member function）*来说，类名也是该函数类型的组成部分。例如：

    ```cpp
    char& String::operator[](int index); // 类型： char& String::(int)
    ```

  - 多个同名函数的定义被称为*函数重载（function overloading）*， 是泛型编程(§7.2)的重要组成部分。 当函数被重载，所有同名函数应当具有相同的语义。

- 为提高长文本的可读性，可以使用单引号（`'`）作为数字分隔符。 例如：*π* 大概是 `3.14159'26535'89793'23846'26433'83279'50288`， 如果用十六进制就是 `0x3.243F'6A88'85A3'08D3`

- **初始化：**

  - 在某个对象被使用之前，必须给定一个值。 C++ 有多种初始化方法，比如上面用到的 `=`， 还有一种通用形式，基于花括号内被隔开的初值列表：

    ```cpp
    double d1 = 2.3;                // d1 初始化为 2.3
    double d2 {2.3};                // d2 初始化为 2.3
    double d3 = {2.3};              // d3 初始化为 2.3（使用 { ... } 时，此处的 = 可有可无）
    complex<double> z = 1;          // 一个复数，使用双精度浮点数作为标量
    complex<double> z2 {d1,d2};
    complex<double> z3 = {d1,d2};   // （使用 { ... } 时，此处的 = 可有可无）
    
    vector<int> v {1,2,3,4,5,6};    // 一个承载 int 的 vector
    ```

  - **缩窄转换（narrowing conversion）** 这种有损信息的形式， 比如`double`到`int`以及`int`到`char`，**在使用`=`（而非`{}`）的时候， 会被默许并悄无声息地进行**。

  - **auto:**定义变量时，如果可以从初始值中推导出类型，就无需明确指定; 此时往往使用`=`

    ```cpp
    auto b = true;      // bool类型
    auto ch = 'x';      // char类型
    auto i = 123;       // int类型
    auto d = 1.2;       // double类型
    auto z = sqrt(y);   // 无论sqrt(y)返回什么类型，z都被指定为该类型
    auto bb {true};     // bb是bool类型
    ```

- **作用域（后两者后续学习）：**
  - **局部作用域（local scope）**： 声明在**函数或lambda表达式**内部的名称， 被称为*局部名称（local name）*。 它的作用域从声明的位置，延续到其声明所驻的代码块末尾。 *代码块（block）*由一对`{}`界定。函数参数的名称也被视为局部名称。
  - **类作用域（class scope）**： 定义在类中，且**在任何函数、 lambda表达式和`enum类`之外**的名称， 被称为*成员名称（member name）*——也叫*类成员名称（class member name）*。 其作用域从容纳它的类声明的左花括号`{`开始，到这个类声明的末尾。
  - **命名空间作用域（namespace scope）**： 如果名称被定义在一个**命名空间（namespace）**里，且在任何函数(§1.3)、 lambda表达式(§6.3.2)、类、和`enum类`(§2.5)之外， 就称之为*命名空间成员名称（namespace member name）*。 其作用域从声明所在位置开始，直至命名空间结尾。

- **常量：**

  - `const`： 编译器为`const`作出的“保证”担保。**一个`const`的值可在运行期间得出**。
  - `constexpr`：相当于“将在编译期估值”。 它主要用于定义常量，指定该数据被置于只读内存（在这里被损坏的几率极低）中， 并且在性能方面有益。 `constexpr`的值必须由编译器算出
    - 有点类似C里的`#define`
    - 但是`constexpr`带类型、作用域和语义，并非是纯文本替换
    - `constexpr`函数可以用于非常量的参数；函数必须极其简单，且不能有副作用，且只能以传入的数据作为参数

- **引用：C++ 里的 `&`就是： 给一个已有变量起一个“别名（alias）”**

  - a 是一个变量；r 是 a 的引用（别名）；`r` 和 `a` 指向的是同一个东西

    ```cpp
    int a = 10;
    int& r = a;
    ```

  - **引用必须初始化**

    ```cpp
    int& r;     // 错误
    ```

  - **引用不能重新绑定**

  - **引用不是对象**（本质是别名），因此**从c++语义上也不会为其分配内存**（但编译器实际操作中，可能会将其视为指针从而分配内存）

  - 常用于函数传参：

    - 此时并非生成一个局部变量，而是可以直接修改实参

    ```cpp
    void addOne(int& x) {
        x++;
    }
    
    int a = 5;
    addOne(a);   // a 变成 6
    ```

  - **const引用（常用）**：

    ```cpp
    void print(const std::string& s) {
        std::cout << s;
    }
    ```

    - 不拷贝；不允许修改；可以绑定临时对象
    - 若违反，在**编译期就会报错**

  - | 对比             | 引用 `&` | 指针 `*` |
    | ---------------- | -------- | -------- |
    | 是否必须初始化   | ✅        | ❌        |
    | 是否可为空       | ❌        | ✅        |
    | 是否可重新指向   | ❌        | ✅        |
    | 使用是否需要 `*` | ❌        | ✅        |

#### 忠告

```
[1] 别慌！船到桥头自然直；§1.1; [CG: In.0]。
[2] 不要专门或单独使用内置特性。 恰恰相反，基本（内置）特性，最好借助程序库间接使用， 比方说 ISO C++ 标准库（第8-15章）；[CG: P.10]。
[3] 想写出好程序，不必对C++掌握到巨细靡遗。
[4] 把力气用在编程技术上，别死磕语言特性。
[5] 有关语言定义相关问题的最终解释， 请参考 ISO C++ 标准；§16.1.3; [CG: P.2]。
[6] 把有用的操作“打包”成函数，再取个好名字；§1.3; [CG: F.1]。
[7] 函数应当仅具有单一的逻辑功能；§1.3; [CG: F.2]。
[8] 保持函数简短；§1.3; [CG: F.3]。
[9] 当函数针对不同类型执行同样概念的操作时，请采用重载；§1.3。
[10] 当函数可能在编译期估值时，用constexpr声明它；§1.6; [CG: F.4]。
[11] 去理解基本语义向硬件的映射；§1.4, §1.7, §1.9, §2.3, §4.2.2, §4.4。
[12] 用数字分隔符为大文本值提高可读性；§1.4; [CG: NL.11]
[13] 不要使用复杂表达式；[CG: ES.40]
[14] 不要使用导致范围缩小的类型转换；§1.4.2; [CG: ES.46]
[15] 尽量让变量的作用域保持最小；§1.5
[16] 不要使用“魔数”；使用符号常量；§1.6; [CG: ES.45]。
[17] 尽量用不可变更的数据；§1.6; [CG: P.10]。
[18] 每个声明里有（且仅有）一个名称；[CG: ES.10]
[19] 保持常见和局部名称简短，让不常见和非局部名称长一些；[CG: ES.7]。
[20] 不要使用形似的名称；[CG: ES.8]。
[21] 不要使用全大写（ALL_CAPS）名称；[CG: ES.9]。
[22] 在提及类型的声明里，尽量用{}-初始化 语法；§1.4; [CG: ES.23]。
[23] 使用auto以避免重复输入类型名；§1.4.2; [CG: ES.11]。
[24] 尽量别弄出来未初始化的变量；§1.4; [CG: ES.20]。
[25] 尽量缩小作用域；§1.5; [CG: ES.5]。
[26] 如果在if-语句的条件中定义变量，尽量采用针对0的隐式判定；§1.8。
[27] 仅在涉及位操作时，使用unsigned；§1.4; [CG: ES.101] [CG: ES.106]。
[28] 确保对指针的使用简单且直白；§1.7; [CG: ES.42]。
[29] 用nullptr，而非0或NULL；§1.7; [CG: ES.47]。
[30] 在有值去初始化它之前，别声明变量；§1.7, §1.8; [CG: ES.21]。
[31] 别给直观的代码写注释； [CG: NL.1]。
[32] 用注释阐释意图；[CG: NL.2]。
[33] 保持缩进风格一致；[CG: NL.4]。
```



## 2. User-Defined Types

### Class(初步)

- 类是对一类事物的抽象，封装了“**数据（成员变量）”和“行为（成员函数）**”

- 类拥有一组*成员（member）*，成员可以是数据、函数或者类型成员。 接口由类的`public`成员定义，而`private`成员仅允许通过接口访问。

- 和类具有相同名称的成员“函数（function）”叫做*构造函数（constructor）*， 就是说，这个函数的用途是构建此类对象

### union

- 联合（`union`）就是结构体（`struct`），只不过联合的所有成员都分配在相同的地址上， 因此联合所占据的空间，仅跟其容量最大的那个成员相同。
- *类型信息（type field）*和`union`所持的类型之间的一致性很难维护。 想要避免错误，可以强化这种一致性——**把联合与类型信息封装成一个类**， 仅允许通过成员函数访问它们，再用成员函数确保准确无误地使用联合。

### enum

```cpp
enum class Color { red, blue, green };
enum class Traffic_light { green, yellow, red };

Color col = Color::red;
Traffic_light light = Traffic_light::red;
```

- `enum`后的`class`指明了这是个强类型的枚举，并且限定了这些枚举值的作用域

  - **枚举值（比如`red`）位于其`enum class`的作用域里**， 因此可以在不同的`enum class`里重复出现，而且不会相互混淆。 
  -  可以省掉`enum class`中的`class`，以获得一个“普通”`enum`。 **“普通”`enum`中的枚举值的作用域跟这个`enum`相同**，还能隐式转换成整数值

- **强枚举类型的内存大小**：

  - 它占用的内存大小等于该枚举类型的底层类型大小，而不是固定等于 `int`（通常是int）
  - 在工程中，显示指定底层类型会很好：

  ```cpp
  enum class Color : uint8_t {
      Red,
      Green,
      Blue
  };
  
  sizeof(Color) == 1   
  ```



## 3. Modularity

### 分离编译

- C++支持分离编译，这种情况下，对于用到的类型和函数，用户仅能见到它们的声明。
- 简单来说，声明写在.h文件中，定义写在cpp文件中
- 可以被独自（包括`#include`进来的`.h`文件）编译的`.cpp`文件， 叫做*编译单元（translation unit）*。

### module(c++20)

- 如果在101个编译单元中用到`#include header.h`， `header.h`中的文本将被编译器处理101次。

- 使用`module`的方法是：在需要的地方`import`它。（like python?）例如：

  ```cpp
  // 文件 user.cpp:
  
  import Vector;      // 获取Vector的接口
  #include <cmath>    // 获取标准库中的数学函数，其中包括sqrt()
  
  double sqrt_sum(Vector& v)
  {
      double sum = 0;
      for (int i=0; i!=v.size(); ++i)
          sum+=std::sqrt(v[i]);       // 平方根的和
      return sum;
  }
  ```

- **module和头文件的差异**：
  - 模块仅编译一次（而非在每个用到的编译单元都处理）
  - 两个模块的`import`顺序可任意颠倒，而不会影响其意义
  - 如果把什么东西导入到一个模块，该模块的用户无法隐式访问到被导入的东西， 以至于引起麻烦：`import`不会跨模块传导。
- **TO DO:** module的编译流程，和头文件编译的区别

### namespace

- 与某些声明相互依托，以便这些名称不会跟其它名称发生冲突

- 例如我自己写的函数complex和标准库中complex具体实现可能不同，使用时使用命名空间名进行限定，比如`std::cout`和`My_code::main`）

- **using：**

  ```cpp
  using namespace std;
  Copy
  ```

  在`using`-指令所处的作用域内，它提及的命名空间内的所有名称都能以非限定方式访问。 因此在针对`std`的`using`-指令后，我们可以直接用`cout`代替`std::cout`

### 错误处理

- 此处不深入，实际工程中再学习
- 简洁高效利用异常进行错误处理，**RAII**至关重要。 充斥着`try`-块的代码往往体现了错误处理策略中最糟糕的方面， 这种情形应该采用错误码。

### 函数传参：

- 关心性能的时候，通常对小型的值传值而较大的值传引用。

- 函数参数带有缺省值的情形也很常见；就是说，一个首选值或者最常用的值。 可以使用*缺省函数参数（default function argument）*进行指定

- **函数本身的引用：**

  | 场景         | 推荐写法        |
  | ------------ | --------------- |
  | 返回内部对象 | `T& / const T&` |
  | 返回新结果   | `T`             |
  | 局部变量     | ❌ 不可返回引用  |



## Others

### new（内存布局相关）

- `new`运算符从一块叫*自由存储（free store）* （也叫*动态内存（dynamic memory）*和*堆（heap）*）的区域里分配内存。 分配在自由存储上的对象，与其被创建的作用域无关， 而是会一直“存活”下去，直到用`delete`运算符把它销毁

- 一个典型的c++程序的内存布局：

  ```
  高地址
  ┌──────────────────┐
  │      Stack       │ ← 局部变量、函数调用
  ├──────────────────┤
  │      Heap        │ ← new / malloc
  ├──────────────────┤
  │   BSS Segment    │ ← 未初始化的全局/静态变量
  ├──────────────────┤
  │  Data Segment    │ ← 已初始化的全局/静态变量
  ├──────────────────┤
  │   Text Segment   │ ← 代码
  └──────────────────┘
  低地址
  ```

  - 各区域含义：
    - **Text / Code 段（代码区）**：大小为程序代码的大小；**在编译期确定**
    - **Data/Bss**: **大小在链接时确定**；程序启动时一次性映射
    - **Stack**：大小通常是固定上限；**由OS/线程创建时决定**；windows默认为1MB
    - **Heap**：理论最大=虚拟内存；实际受限于系统内存、地址空间、OS策略
  - **程序启动时，操作系统并不是“从系统内存中直接划一整块物理内存”给程序； 而是为进程建立一个“虚拟地址空间”，并映射：**
    - text segment
    - data / BSS
    - 初始的 stack
  - heap 并不是一开始就有很多，而是在运行过程中“按需向 OS 申请扩展虚拟内存”
  - 这些虚拟地址空间本身存储在**页表（page table)**里；此处不展开
  - 何时分配实际的物理内存：
    - **物理内存通常在“第一次真正访问（读 / 写 / 执行）某个虚拟页”时才会分配**
    - 例如写变量、读变量、执行代码（text段按需写入）、栈变量初始化
    - 声明变量、malloc/new都只是分配虚拟内存空间，并不会直接申请物理页

- **new分配的内存和全局变量的区别**：

  - `new` 分配的内存在“堆（heap）”上； 全局变量在“静态存储区（data / bss）”中。

  - | 项目     | new      | 全局变量 |
    | -------- | -------- | -------- |
    | 分配时机 | 运行期   | 程序启动 |
    | 释放时机 | `delete` | 程序结束 |
    | 是否可控 | ✅        | ❌        |

  - 